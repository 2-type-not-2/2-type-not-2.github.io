Disagreement:

For \lstinline[style=custominlinejs]|babel/babel-loader:82|, two strong 
disagreements, one on Flow and the other on TypeScript, arose because
one author noticed the use of built-in globals in the Right-Hand-Side of an 
assignment and did not consider
whether the variables stored into the global were locally defined and thus could
be annotated. For 
\lstinline[style=custominlinejs]|gevgeny/highcharts-flags-grouping:1|
\lstinline[style=custominlinejs]|iamvdo/pleeease-cli:4| and 
\lstinline[style=custominlinejs]|thedersen/backbone.validation:17|, three strong 
disagreements on Flow arose because the 
dissenting author considered missing
predicates to be specification errors and did not consider whether type
annotations could replace those predicates.  The patch for 
\lstinline[style=custominlinejs]|wolverian/jenky:11| both
places typeable locals into a global object and adds new predicates;  this
caused two disagreements. For 
\lstinline[style=custominlinejs]|kbrivois/spacelash:5|, two arose for two 
interlocking reasons.  First, the patch tangles fixing a performance bug via 
changing constants and removing an implicitly declared global variable;  second, 
both Flow and TypeScript enforce JavaScript's strict mode, which will report an
error on an implicitly global declaration, regardless of whether or not the
program specifies it.  The dissenting author added an annotation that triggered
an error on the implicitly global declaration, but failed to notice that the
code did not specify the strict mode and, moreover, the implicit declaration had
nothing to do with the bug report which complained about performance. For 
\lstinline[style=custominlinejs]|seldo/nunjucks-hapi:1|, two disagreements were 
concerning missing libraries due to typos in the arguments of import calls.
Clearly, Flow and TypeScript report such library errors. The dissenter thought
that Flow and TypeScript were using a non-type-based analysis to report these
errors and forgot that this experiment focused on reporting what the type
checker reports, not whether or not a bug is type checkable in theory. For 
\lstinline[style=custominlinejs]|naugtur/transitionrunner:1|, a strong
disagreement on TypeScript arose. Here, the author who triggered the bug added 
a cast to a library call that specified that the return could be
\lstinline[style=custominlinejs]|null| and tried to store that directly into a
nonnullable variable that flows into a \lstinline[style=custominlinejs]|string|
addition.  The other authors did not find this annotation and worried that the
cast is not a shim, but, rather, commits the sin of marking a bug location with
an uninhabitable type annotation (Definition~\autoref{def:tc_preventable}). We 
conservatively deemed this bug to be TypeScript-unpreventable.